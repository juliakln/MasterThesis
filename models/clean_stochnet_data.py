""" Read simulated Stochnet Trajectories & Stead-State data
and save transient histograms or expected means over time
"""

import numpy as np
import os
import sys
import matplotlib.pyplot as plt
from scipy.integrate import odeint, solve_ivp
import pickle



def load_data(case, id):
    """ Load traces generated by StochNet (time, bees, dead bees, pheromone),
        histogram data and the initial settings 
    """
    traces = np.load(f'../home/dn/DATA/Bees/new/{case}/{id}/steadystate.npy')
    hist = np.load(f"../home/dn/DATA/Bees/new/{case}/{id}/histogram_dataset.npy")
    settings = np.load(f"../home/dn/DATA/Bees/new/{case}/{id}/histogram_settings.npy")
    return traces, hist, settings


def stoch_mean(traces, n, t):
    """ Calculate the expected mean of bees, dead bees and pheromone from traces
        of initially n bees and n pheromone and plot it over time until time t
    """
    traces = traces[:,0:(t*10),:]
    fig = plt.figure(figsize=(12,4))
    # plot stochastic expected mean
    for i in list(range(1,4)):
        traces_part = traces[:,:,i]
        part_avg = [(sum(x) / len(x))/n for x in zip(*traces_part)]
        pickle.dump(part_avg, open(f'../histograms/avg_{i}.pickle', 'wb'))
        plt.plot(np.arange(0,(t*10),1), part_avg, alpha=0.7)
    plt.legend(['Bees', 'Dead', 'Pheromone'], loc='best')
    plt.xticks(np.arange(0,2250,250), np.arange(0,22.5,2.5))
    plt.xlabel('t')
    plt.ylabel('E[x]', rotation=0)
    #plt.show() 
    #plt.savefig(f'../histograms/stochastic_{n}bees.png')
    #plt.close()


def stoch_singleruns(traces, n, t, runs, ode):
    """ Plot several single simulation runs over time for initially n bees until time t
        runs : number of trajectories to plot
        ode : boolean if ode solution should be printed as well
    """
    traces = traces[0:runs,0:(t*100),:]

    for r in list(range(0,runs)):
        plt.plot(traces[0,:,0], traces[r,:,1]/n, color='#1f77b4', linewidth=0.7, alpha=0.6)
        plt.plot(traces[0,:,0], traces[r,:,2]/n, color='#ff7f0e', linewidth=0.7, alpha=0.6)
        plt.plot(traces[0,:,0], traces[r,:,3]/n, color='#2ca02c', linewidth=0.7, alpha=0.6)
    if ode:
        sol = run_ode_bees(pop = [1], t = t, k1=1, k2=1, plot=False)
        t2 = np.linspace(0,t,101)
        plt.plot(t2, sol.T, color='black', linewidth=2, linestyle='dashed')
    plt.legend(['Bees', 'Dead', 'Pheromone'], loc='best')
    plt.xlabel('t')
    plt.ylabel('E(x)/N')
    #plt.show()
    plt.savefig(f'../histograms/stochastic_singleruns_{n}bees.png')
    plt.close()


def stoch_singleruns_sep(traces, n, t, runs):
    """ Plot several single simulation runs in 3 different plots (bees, dead bees, pheromone)
    """
    traces = traces[0:runs,0:(t*10),:]

    fig, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(14,6), sharex=True, sharey=True)
    fig.suptitle(f'{runs} simulation runs (trajectories) of stochastic model')
    ax1.set_title('Bees')
    ax2.set_title('Dead Bees')
    ax3.set_title('Pheromone')
    for t in list(range(0,runs)):
        ax1.plot(traces[0,:,0], traces[t,:,1]/n)
        ax2.plot(traces[0,:,0], traces[t,:,2]/n)
        ax3.plot(traces[0,:,0], traces[t,:,3]/n)
    ax2.set_xlabel('t')
    plt.show()
    #plt.savefig(f'../histograms/stochastic_singleruns_sep_{n}bees.png')
    #plt.close()


def stoch_transient(pop, case):
    """ Calculate the transient number of dead bees for different pop (population sizes)
        Plot mean value together with noise
        Noise is either from min to max value, or +- standard deviation
    """
    i = 0
    min_v, max_v, mean_v, sd_v = [], [], [], []
    for dirpath, dirnames, filenames in os.walk(f"../home/dn/DATA/Bees/new/{case}"):
        for filename in [f for f in filenames if f.endswith("state.npy")]:
            case = dirpath.split("\\")[1]
            n = pop[i]
            traces = np.load(os.path.join(dirpath, filename))
            # steady state of dead bees (last line)
            traces = traces[:,-1,2]/n
            min_v.append(np.min(traces))
            max_v.append(np.max(traces))
            mean_v.append(np.mean(traces))
            sd_v.append(np.std(traces))
            i+=1

    fig, (ax1, ax2) = plt.subplots(1,2, figsize=(14,6), sharex=True, sharey=True)
    fig.suptitle('Transient average after t=20 for 10000 trajectories')
    ax1.set_title('Shaded area represents noise (min to max value)')
    ax2.set_title('Shaded area represents noise (mean +- standard deviation)')
    ax1.plot(pop, mean_v)
    ax1.fill_between(pop, min_v, max_v, alpha=0.1)
    ax1.set_xlabel('Population size N')
    ax2.plot(pop, mean_v)
    ax2.fill_between(pop, [x - y for x, y in zip(mean_v, sd_v)], 
                    [x + y for x, y in zip(mean_v, sd_v)], alpha=0.1)
    ax2.set_xlabel('Population size N')
    fig.text(0.04, 0.5, 'E(Dead Bees) / N', ha='center', va='center', rotation='vertical')
    plt.show()
    #plt.savefig(f'../histograms/stoch_transient.png')
    return min_v, max_v, mean_v, sd_v


def stoch_transient_error(pop, case):
    """ Calculate the transient means for different pop (population sizes)
        Calculate error to ODE solution and plot for bees, dead bees and pheromone
    """
    i = 0
    mean_b, mean_d, mean_p, sd_d = [], [], [], []
    for dirpath, dirnames, filenames in os.walk(f"../home/dn/DATA/Bees/new/{case}"):
        for filename in [f for f in filenames if f.endswith("state.npy")]:
            case = dirpath.split("\\")[1]
            n = pop[i]
            traces = np.load(os.path.join(dirpath, filename))
            # steady state of dead bees (last line)
            bees = traces[:,-1,1]/n
            dead = traces[:,-1,2]/n
            pher = traces[:,-1,3]/n

            mean_b.append(np.mean(bees))
            mean_d.append(np.mean(dead))
            sd_d.append(np.std(dead))
            mean_p.append(np.mean(pher))
            i+=1
    ode = [0.15781122093261007, 0.8421887790673899, 1.9870060097321148e-07]
    plt.rcParams["figure.figsize"] = (8,6)
    plt.axhline(y=ode[0], color='black', linewidth=0.8, linestyle='dashed')
    plt.axhline(y=ode[1], color='black', linewidth=0.8, linestyle='dashed', label='_nolegend_')
    plt.axhline(y=ode[2], color='black', linewidth=0.8, linestyle='dashed', label='_nolegend_')
    plt.plot(pop, mean_b)
    plt.plot(pop, mean_d)
    plt.plot(pop, mean_p)
    plt.legend(['ODE', 'Bees', 'Dead', 'Pheromone'], loc='best')
    plt.xlabel('Population size N')
    plt.ylabel('E(x)/N')
    plt.show()

    plt.rcParams["figure.figsize"] = (8,6)
    plt.plot(pop, [abs(x - ode[0]) for x in mean_b])
    plt.plot(pop, [abs(x - ode[1]) for x in mean_d])
    plt.plot(pop, [abs(x - ode[2]) for x in mean_p])
    plt.legend(['Bees', 'Dead', 'Pheromone'], loc='best')
    plt.xlabel('Population size N')
    plt.ylabel('err(ode, stoch)')
    plt.show()

    plt.rcParams["figure.figsize"] = (8,6)
    plt.plot(pop, [abs(x - ode[1]) for x in mean_d], color='r')
    plt.plot(pop, sd_d, color='b')
    plt.legend(['Accuracy', 'Precision'], loc='best')
    plt.xlabel('Population size N')
    plt.show()
    

def hist_varyN(pop, case):
    """ Calculate the transient histogram for different pop (population sizes)
        Save in txt file with frequencies
    """
    i = 0
    for dirpath, _, filenames in os.walk(f"../home/dn/DATA/Bees/{case}"):
        for filename in [f for f in filenames if f.endswith("state.npy")]:
            case = dirpath.split("\\")[1]
            n = pop[i]
            traces = np.load(os.path.join(dirpath, filename))
            # save number of stinging bees
            dead = traces[:,-1,2]
            unique, counts = np.unique(dead, return_counts=True)

            with open(f"../../MasterThesis/data/stochnet/bees_{n}.txt", "w") as f:
                f.write(str(unique))
                f.write('\n')
                f.write(str(counts))

            i+=1

def hist_varyNk(pop, rates, case):
    """ Calculate the transient histogram for different pop (population sizes)
        Save in txt file with frequencies
    """
    i = 0
    j = 0
    for dirpath, _, filenames in os.walk(f"../home/dn/DATA/Bees/{case}"):
        for filename in [f for f in filenames if f.endswith("state.npy")]:
            case = dirpath.split("\\")[1]
            n = pop[i]
            k = rates[j]
            traces = np.load(os.path.join(dirpath, filename))
            # save number of stinging bees
            dead = traces[:,-1,2]
            unique, counts = np.unique(dead, return_counts=True)

            with open(f"../../MasterThesis/data/stochnet2/bees_{n}_{k}.txt", "w") as f:
                f.write(str(unique))
                f.write('\n')
                f.write(str(counts))

            if(j==(len(rates)-1)):
                i+=1
                j=0
            else:
                j+=1


def hist_steady(steady, n, p, case):
    """ Create histogram of number of dead bees from steady state data, initially n bees, 
        p phermone, case (which rates)
    """
    unique, counts = np.unique(steady, return_counts=True)
    plt.figure(figsize=(10,6))
    plt.bar(unique, counts, 0.8, color="steelblue")
    plt.xticks(np.arange(n+1))
    plt.suptitle(f'Simulated data for {n} bees after 10000 trajectories',
                        fontsize=15)
    plt.title(f'Initial pheromone = {p}, {case}, add calm down reaction',
                    fontsize=10)
    plt.xlabel('Number of stinging bees')
    #plt.savefig(f'../histograms/{case}/{n}bees.png')
    plt.show()


def ode_bees(t, y, k1, k2):
    """ ODE system of 2 reactions for bees example
    """
    bee, dead, p = y
    dydt = [-k1*bee*p, k1*bee*p, ((k1*bee*p) - (k2*p))]
    return dydt
          

def run_ode_bees(pop, t, k1, k2, plot):
    """ Numerical solution of ODE model for bees of population sizes pop
    until time t with initial condition y0 and rates k1 and k2
    """
    for n in pop:
        y0 = [n, 0, n]
        t2 = np.linspace(0,t,101)
        sol = solve_ivp(ode_bees, [0,t], y0, args=(k1, k2), dense_output=True)
        z = sol.sol(t2)
        print(f'\nSolution for {n} Bee')
        if plot:
            plt.plot(t2, z.T)
            plt.legend(['Bees', 'Dead', 'Pheromone'], loc='best')
            plt.xlabel('t')
            plt.show()  
            #plt.savefig(f'ode_sig_{n}.png') 
            #plt.close()
        print('Alive Bees:', sol.y[0,-1])
        print('Dead Bees: ', sol.y[1,-1])
        print('Pheromone: ', sol.y[2,-1])
        return z



def main():
    # Stochastic
    traces, hist, settings = load_data('CaseA', '31')
    stoch_mean(traces, 100, 200)  # print expected number for 10000 simulations
    #stoch_singleruns(traces, 100, 20, 15, True)

    # Transient
    #nbees = np.arange(15,155,5)
    #stoch_transient_error(pop=nbees, case='CaseA')

    #hist_varyN(pop=nbees, case='new_thesis1')
    # ODE
    #k1, k2 = 1, 1
    #nbees = np.arange(15,90,5)
    #ratesk1 = np.linspace(0.01, 0.07, 15)
    #hist_varyNk(pop=nbees, rates=ratesk1, case='new_thesis2')


if __name__ == "__main__":
    sys.exit(main())
